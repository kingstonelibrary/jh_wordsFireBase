var __wpo = {
  "assets": {
    "main": [
      "./icons/apple-touch-icon-57x57.png",
      "./icons/apple-touch-icon-60x60.png",
      "./icons/apple-touch-icon-72x72.png",
      "./icons/apple-touch-icon-76x76.png",
      "./icons/apple-touch-icon-114x114.png",
      "./icons/apple-touch-icon-120x120.png",
      "./icons/apple-touch-icon-152x152.png",
      "./icons/apple-touch-icon-144x144.png",
      "./icons/apple-touch-icon-180x180.png",
      "./icons/apple-touch-icon.png",
      "./icons/apple-touch-icon-167x167.png",
      "./icons/apple-touch-icon-precomposed.png",
      "./icons/favicon-16x16.png",
      "./icons/favicon-32x32.png",
      "./icons/favicon.ico",
      "./icons/android-chrome-36x36.png",
      "./icons/android-chrome-48x48.png",
      "./icons/android-chrome-72x72.png",
      "./icons/android-chrome-96x96.png",
      "./icons/android-chrome-144x144.png",
      "./icons/android-chrome-192x192.png",
      "./icons/android-chrome-256x256.png",
      "./icons/android-chrome-384x384.png",
      "./icons/android-chrome-512x512.png",
      "./icons/mstile-70x70.png",
      "./icons/mstile-144x144.png",
      "./icons/mstile-150x150.png",
      "./icons/mstile-310x150.png",
      "./icons/mstile-310x310.png",
      "./icons/firefox_app_60x60.png",
      "./icons/firefox_app_128x128.png",
      "./icons/firefox_app_512x512.png",
      "./icons/apple-touch-startup-image-320x460.png",
      "./icons/apple-touch-startup-image-640x920.png",
      "./icons/apple-touch-startup-image-640x1096.png",
      "./icons/apple-touch-startup-image-748x1024.png",
      "./icons/apple-touch-startup-image-750x1294.png",
      "./icons/apple-touch-startup-image-768x1004.png",
      "./icons/apple-touch-startup-image-1182x2208.png",
      "./icons/apple-touch-startup-image-1242x2148.png",
      "./icons/apple-touch-startup-image-1496x2048.png",
      "./icons/apple-touch-startup-image-1536x2008.png",
      "./manifest.json",
      "./icons/browserconfig.xml",
      "./manifest.webapp",
      "./images/cracker.png",
      "./webpack-bundle.js",
      "./",
      "./data.json"
    ],
    "additional": [],
    "optional": []
  },
  "externals": [],
  "hashesMap": {
    "dd4fbcae14d1c7eebdbb1124edd3b376428275d1": "./icons/apple-touch-icon-57x57.png",
    "fa3138d412858e9e547a46cab8c6ec2268d8eb6c": "./icons/apple-touch-icon-60x60.png",
    "8da95cc3ac0cb77d82a9b6aca10f512ec39e28a6": "./icons/android-chrome-72x72.png",
    "e182317565c94190c613c8940eba723f44d3ccdf": "./icons/apple-touch-icon-76x76.png",
    "7b1e228ef1c2a7bee18d4ad86e2292488cbbb8c6": "./icons/apple-touch-icon-114x114.png",
    "9b055378bbf087b7b698235f0f2c599c108a153d": "./icons/apple-touch-icon-120x120.png",
    "bbfaa5899acf634e8549d7da4c535766ee40b3a8": "./icons/apple-touch-icon-152x152.png",
    "8a4149b339690cd3c0c15cf679424aab1fc7dc35": "./icons/mstile-144x144.png",
    "df22b9ec57743c8568cd9566a870861472397e3b": "./icons/apple-touch-icon-precomposed.png",
    "9c484b41eb323f36cb9a626fe126efbecf19d240": "./icons/apple-touch-icon-167x167.png",
    "88b544373a0b4f427ed4883753f7d25e201382ee": "./icons/favicon-16x16.png",
    "5021e841977256db3663ee3d106fd9df7c7cd614": "./icons/favicon-32x32.png",
    "959fdf1f6044066030319f9475935879e1e68189": "./icons/favicon.ico",
    "477309b5853d2d5d7dde4636aa8b9a4eceb30dbe": "./icons/android-chrome-36x36.png",
    "dd67c089900414c2c5b501a7e224f79cbda876b9": "./icons/android-chrome-48x48.png",
    "55a4a7f9ac8c9e3df36d791ecf60bac79fc105c4": "./icons/android-chrome-96x96.png",
    "4f7963e6215c5e49c6eb741d583cafbab7ef6b50": "./icons/android-chrome-192x192.png",
    "a8cb2fedbcb677377cae2a62e57510e2a41edaa2": "./icons/android-chrome-256x256.png",
    "41e2b11d0bd8f8d60805f42660fa14d18c35efe9": "./icons/android-chrome-384x384.png",
    "75ef9e1de98b0c3c62ae382a1a92eed2e896b4b2": "./icons/android-chrome-512x512.png",
    "a34a5bcf4ef991d43e7b5de53660cce4cc2128f3": "./icons/mstile-70x70.png",
    "e1f173f3f66d6270e6b0d2a7b41b2cbe297d3301": "./icons/mstile-150x150.png",
    "244a005c222303d070bc4f0852bac4bda070f048": "./icons/mstile-310x150.png",
    "65ed31fbf53b4eb31b6d77de9630f3e714d431cc": "./icons/mstile-310x310.png",
    "03275546feaebe2607e0b65ba8c91cfea68d160b": "./icons/firefox_app_60x60.png",
    "a3f044da8b6f8e023f32c5d7b29fd1b95720a7b8": "./icons/firefox_app_128x128.png",
    "1ef42c7fce11251a5412ca6b16eb7943beb12ba7": "./icons/firefox_app_512x512.png",
    "fca1e6b95b5e24addb74d5cd3da7328712070aec": "./icons/apple-touch-startup-image-320x460.png",
    "c526e1f46896cd5eb1e18a63f0b45ed9a5503430": "./icons/apple-touch-startup-image-640x920.png",
    "f06854a3060d87b7927a915983ba8c26e54074f7": "./icons/apple-touch-startup-image-640x1096.png",
    "3e1cfeda79859afb58a5b47493755cba6f9578d9": "./icons/apple-touch-startup-image-748x1024.png",
    "ab6671a60e2edcbd11550aba97988a353e1f08a1": "./icons/apple-touch-startup-image-750x1294.png",
    "c3d2569993a99af15d614196b90d8a70784ac927": "./icons/apple-touch-startup-image-768x1004.png",
    "adbc71275a3fbe1d19df52966765f97c82f14fe3": "./icons/apple-touch-startup-image-1182x2208.png",
    "92f7880114cda20c4e3d2c67c7ac27d22fc579b8": "./icons/apple-touch-startup-image-1242x2148.png",
    "70227f3edb8e42c9a225cff06c3de5c9c62e0ccd": "./icons/apple-touch-startup-image-1496x2048.png",
    "e9cc8e2775a4f2e90cf29ad99b5a74c00a6d8e5d": "./icons/apple-touch-startup-image-1536x2008.png",
    "c9ad292bbc9a4d6ac0a7372cd411306c56177aa1": "./icons/manifest.json",
    "5b4f37d41ff649e9eeeb04ca9cc8b94c6757c986": "./icons/browserconfig.xml",
    "cdfbeeab1018af59c6777a20775cbdfccca50f75": "./icons/manifest.webapp",
    "0b81ea3a0e1fe4336489627f59a345033445ade1": "./images/cracker.png",
    "907372c4814aa085e62cb02ea41d8f2690a93071": "./webpack-bundle.js",
    "c5e901aa43651e672a99f7eec7f7f53a4c7190c0": "./",
    "7a3dbebf95a8cc46d6e850ea81ffb93516ef092b": "./data.json"
  },
  "strategy": "changed",
  "responseStrategy": "cache-first",
  "version": "2019-09-25 12:43:08",
  "name": "webpack-offline",
  "pluginVersion": "5.0.6",
  "relativePaths": true
};


self.addEventListener("fetch", function(event) {
  console.log("[SW] fetch event (global scope fecth handler)");
});
self.addEventListener("push", function(event) {
  //送られたプッシュ通知の本文を表示
  if (Notification.permission == "granted") {
    console.log("[SW] Push Notification Recieved", event);
    event.waitUntil(
      self.registration
        .showNotification(event.data.json().notification.title, {
          body: event.data.json().notification.body,
          icon: event.data.json().notification.icon
        })
        .then(
          function(showEvent) {},
          function(error) {
            console.log(error);
          }
        )
    );
  }
});

/******/ (function(modules) {
  // webpackBootstrap
  /******/ // The module cache
  /******/ var installedModules = {}; // The require function
  /******/
  /******/ /******/ function __webpack_require__(moduleId) {
    /******/
    /******/ // Check if module is in cache
    /******/ if (installedModules[moduleId]) {
      /******/ return installedModules[moduleId].exports;
      /******/
    } // Create a new module (and put it into the cache)
    /******/ /******/ var module = (installedModules[moduleId] = {
      /******/ i: moduleId,
      /******/ l: false,
      /******/ exports: {}
      /******/
    }); // Execute the module function
    /******/
    /******/ /******/ modules[moduleId].call(
      module.exports,
      module,
      module.exports,
      __webpack_require__
    ); // Flag the module as loaded
    /******/
    /******/ /******/ module.l = true; // Return the exports of the module
    /******/
    /******/ /******/ return module.exports;
    /******/
  } // expose the modules object (__webpack_modules__)
  /******/
  /******/
  /******/ /******/ __webpack_require__.m = modules; // expose the module cache
  /******/
  /******/ /******/ __webpack_require__.c = installedModules; // define getter function for harmony exports
  /******/
  /******/ /******/ __webpack_require__.d = function(exports, name, getter) {
    /******/ if (!__webpack_require__.o(exports, name)) {
      /******/ Object.defineProperty(exports, name, {
        enumerable: true,
        get: getter
      });
      /******/
    }
    /******/
  }; // define __esModule on exports
  /******/
  /******/ /******/ __webpack_require__.r = function(exports) {
    /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
      /******/ Object.defineProperty(exports, Symbol.toStringTag, {
        value: "Module"
      });
      /******/
    }
    /******/ Object.defineProperty(exports, "__esModule", { value: true });
    /******/
  }; // create a fake namespace object // mode & 1: value is a module id, require it // mode & 2: merge all properties of value into the ns // mode & 4: return value when already ns object // mode & 8|1: behave like require
  /******/
  /******/ /******/ /******/ /******/ /******/ /******/ __webpack_require__.t = function(
    value,
    mode
  ) {
    /******/ if (mode & 1) value = __webpack_require__(value);
    /******/ if (mode & 8) return value;
    /******/ if (
      mode & 4 &&
      typeof value === "object" &&
      value &&
      value.__esModule
    )
      return value;
    /******/ var ns = Object.create(null);
    /******/ __webpack_require__.r(ns);
    /******/ Object.defineProperty(ns, "default", {
      enumerable: true,
      value: value
    });
    /******/ if (mode & 2 && typeof value != "string")
      for (var key in value)
        __webpack_require__.d(
          ns,
          key,
          function(key) {
            return value[key];
          }.bind(null, key)
        );
    /******/ return ns;
    /******/
  }; // getDefaultExport function for compatibility with non-harmony modules
  /******/
  /******/ /******/ __webpack_require__.n = function(module) {
    /******/ var getter =
      module && module.__esModule
        ? /******/ function getDefault() {
            return module["default"];
          }
        : /******/ function getModuleExports() {
            return module;
          };
    /******/ __webpack_require__.d(getter, "a", getter);
    /******/ return getter;
    /******/
  }; // Object.prototype.hasOwnProperty.call
  /******/
  /******/ /******/ __webpack_require__.o = function(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  }; // __webpack_public_path__
  /******/
  /******/ /******/ __webpack_require__.p = ""; // Load entry module and return exports
  /******/
  /******/
  /******/ /******/ return __webpack_require__((__webpack_require__.s = 0));
  /******/
})(
  /************************************************************************/
  /******/ [
    /* 0 */
    /***/ function(module, exports, __webpack_require__) {
      "use strict";

      (function() {
        var waitUntil = ExtendableEvent.prototype.waitUntil;
        var respondWith = FetchEvent.prototype.respondWith;
        var promisesMap = new WeakMap();

        ExtendableEvent.prototype.waitUntil = function(promise) {
          var extendableEvent = this;
          var promises = promisesMap.get(extendableEvent);

          if (promises) {
            promises.push(Promise.resolve(promise));
            return;
          }

          promises = [Promise.resolve(promise)];
          promisesMap.set(extendableEvent, promises);

          // call original method
          return waitUntil.call(
            extendableEvent,
            Promise.resolve().then(function processPromises() {
              var len = promises.length;

              // wait for all to settle
              return Promise.all(
                promises.map(function(p) {
                  return p["catch"](function() {});
                })
              ).then(function() {
                // have new items been added? If so, wait again
                if (promises.length != len) return processPromises();
                // we're done!
                promisesMap["delete"](extendableEvent);
                // reject if one of the promises rejected
                return Promise.all(promises);
              });
            })
          );
        };

        FetchEvent.prototype.respondWith = function(promise) {
          this.waitUntil(promise);
          return respondWith.call(this, promise);
        };
      })();
      ("use strict");

      if (typeof DEBUG === "undefined") {
        var DEBUG = false;
      }

      function WebpackServiceWorker(params, helpers) {
        var cacheMaps = helpers.cacheMaps;
        // navigationPreload: true, { map: (URL) => URL, test: (URL) => boolean }
        var navigationPreload = helpers.navigationPreload;

        // (update)strategy: changed, all
        var strategy = params.strategy;
        // responseStrategy: cache-first, network-first
        var responseStrategy = params.responseStrategy;

        var assets = params.assets;

        var hashesMap = params.hashesMap;
        var externals = params.externals;

        var prefetchRequest = params.prefetchRequest || {
          credentials: "same-origin",
          mode: "cors"
        };

        var CACHE_PREFIX = params.name;
        var CACHE_TAG = params.version;
        var CACHE_NAME = CACHE_PREFIX + ":" + CACHE_TAG;

        var PRELOAD_CACHE_NAME = CACHE_PREFIX + "$preload";
        var STORED_DATA_KEY = "__offline_webpack__data";

        mapAssets();

        var allAssets = [].concat(
          assets.main,
          assets.additional,
          assets.optional
        );

        self.addEventListener("install", function(event) {
          console.log("[SW] ", "Install event");
          caches.delete(CACHE_NAME);
          var installing = undefined;

          if (strategy === "changed") {
            installing = cacheChanged("main");
          } else {
            installing = cacheAssets("main");
          }

          event.waitUntil(installing);
          event.waitUntil(self.skipWaiting());
        });

        self.addEventListener("activate", function(event) {
          console.log("[SW] ", "Activate event");

          var activation = cacheAdditional();

          // Delete all assets which name starts with CACHE_PREFIX and
          // is not current cache (CACHE_NAME)
          activation = activation.then(storeCacheData);
          activation = activation.then(deleteObsolete);
          activation = activation.then(function() {
            if (self.clients && self.clients.claim) {
              console.log("[SW] claim() was executed!");

              return self.clients.claim();
            }
          });

          if (navigationPreload && self.registration.navigationPreload) {
            activation = Promise.all([
              activation,
              self.registration.navigationPreload.enable()
            ]);
          }

          event.waitUntil(activation);
        });

        function cacheAdditional() {
          if (!assets.additional.length) {
            return Promise.resolve();
          }

          if (DEBUG) {
            console.log("[SW] ", "Caching additional");
          }

          var operation = undefined;

          if (strategy === "changed") {
            operation = cacheChanged("additional");
          } else {
            operation = cacheAssets("additional");
          }

          // Ignore fail of `additional` cache section
          return operation["catch"](function(e) {
            console.error("[SW] ", "Cache section `additional` failed to load");
          });
        }

        function cacheAssets(section) {
          var batch = assets[section];

          return caches
            .open(CACHE_NAME)
            .then(function(cache) {
              return addAllNormalized(cache, batch, {
                bust: params.version,
                request: prefetchRequest,
                failAll: section === "main"
              });
            })
            .then(function() {
              logGroup("Cached assets: " + section, batch);
            })
            ["catch"](function(e) {
              console.error(e);
              throw e;
            });
        }

        function cacheChanged(section) {
          return getLastCache().then(function(args) {
            if (!args) {
              return cacheAssets(section);
            }

            var lastCache = args[0];
            var lastKeys = args[1];
            var lastData = args[2];

            var lastMap = lastData.hashmap;
            var lastVersion = lastData.version;

            if (!lastData.hashmap || lastVersion === params.version) {
              return cacheAssets(section);
            }

            var lastHashedAssets = Object.keys(lastMap).map(function(hash) {
              return lastMap[hash];
            });

            var lastUrls = lastKeys.map(function(req) {
              var url = new URL(req.url);
              url.search = "";
              url.hash = "";

              return url.toString();
            });

            var sectionAssets = assets[section];
            var moved = [];
            var changed = sectionAssets.filter(function(url) {
              if (
                lastUrls.indexOf(url) === -1 ||
                lastHashedAssets.indexOf(url) === -1
              ) {
                return true;
              }

              return false;
            });

            Object.keys(hashesMap).forEach(function(hash) {
              var asset = hashesMap[hash];

              // Return if not in sectionAssets or in changed or moved array
              if (
                sectionAssets.indexOf(asset) === -1 ||
                changed.indexOf(asset) !== -1 ||
                moved.indexOf(asset) !== -1
              )
                return;

              var lastAsset = lastMap[hash];

              if (lastAsset && lastUrls.indexOf(lastAsset) !== -1) {
                moved.push([lastAsset, asset]);
              } else {
                changed.push(asset);
              }
            });

            logGroup("[SW] Changed assets: " + section, changed);
            logGroup("[SW] Moved assets: " + section, moved);

            var movedResponses = Promise.all(
              moved.map(function(pair) {
                return lastCache.match(pair[0]).then(function(response) {
                  return [pair[1], response];
                });
              })
            );

            return caches.open(CACHE_NAME).then(function(cache) {
              var move = movedResponses.then(function(responses) {
                return Promise.all(
                  responses.map(function(pair) {
                    return cache.put(pair[0], pair[1]);
                  })
                );
              });

              return Promise.all([
                move,
                addAllNormalized(cache, changed, {
                  bust: params.version,
                  request: prefetchRequest,
                  failAll: section === "main",
                  deleteFirst: section !== "main"
                })
              ]);
            });
          });
        }

        function deleteObsolete() {
          return caches.keys().then(function(keys) {
            var all = keys.map(function(key) {
              if (
                key.indexOf(CACHE_PREFIX) !== 0 ||
                key.indexOf(CACHE_NAME) === 0
              )
                return;

              console.log("[SW] ", "Delete cache:", key);
              return caches["delete"](key);
            });

            return Promise.all(all);
          });
        }

        function getLastCache() {
          return caches.keys().then(function(keys) {
            var index = keys.length;
            var key = undefined;

            while (index--) {
              key = keys[index];

              if (key.indexOf(CACHE_PREFIX) === 0) {
                break;
              }
            }

            if (!key) return;

            var cache = undefined;

            return caches
              .open(key)
              .then(function(_cache) {
                cache = _cache;
                return _cache.match(
                  new URL(STORED_DATA_KEY, location).toString()
                );
              })
              .then(function(response) {
                if (!response) return;

                return Promise.all([cache, cache.keys(), response.json()]);
              });
          });
        }

        function storeCacheData() {
          return caches.open(CACHE_NAME).then(function(cache) {
            var data = new Response(
              JSON.stringify({
                version: params.version,
                hashmap: hashesMap
              })
            );

            return cache.put(
              new URL(STORED_DATA_KEY, location).toString(),
              data
            );
          });
        }

        self.addEventListener("fetch", function(event) {
          // Handle only GET requests
          if (event.request.method !== "GET") {
            return;
          }

          console.log("[SW] fetch event (inner scope fecth handler)		");

          // This prevents some weird issue with Chrome DevTools and 'only-if-cached'
          // Fixes issue #385, also ref to:
          // - https://github.com/paulirish/caltrainschedule.io/issues/49
          // - https://bugs.chromium.org/p/chromium/issues/detail?id=823392
          if (
            event.request.cache === "only-if-cached" &&
            event.request.mode !== "same-origin"
          ) {
            return;
          }

          var url = new URL(event.request.url);
          url.hash = "";

          var urlString = url.toString();

          // Not external, so search part of the URL should be stripped,
          // if it's external URL, the search part should be kept
          if (externals.indexOf(urlString) === -1) {
            url.search = "";
            urlString = url.toString();
          }

          var assetMatches = allAssets.indexOf(urlString) !== -1;
          var cacheUrl = urlString;

          if (!assetMatches) {
            var cacheRewrite = matchCacheMap(event.request);

            if (cacheRewrite) {
              cacheUrl = cacheRewrite;
              assetMatches = true;
            }
          }

          if (!assetMatches) {
            // Use request.mode === 'navigate' instead of isNavigateRequest
            // because everything what supports navigationPreload supports
            // 'navigate' request.mode
            if (event.request.mode === "navigate") {
              // Requesting with fetchWithPreload().
              // Preload is used only if navigationPreload is enabled and
              // navigationPreload mapping is not used.
              if (navigationPreload === true) {
                event.respondWith(fetchWithPreload(event));
                return;
              }
            }

            // Something else, positive, but not `true`
            if (navigationPreload) {
              var preloadedResponse = retrivePreloadedResponse(event);

              if (preloadedResponse) {
                event.respondWith(preloadedResponse);
                return;
              }
            }

            // Logic exists here if no cache match
            return;
          }

          // Cache handling/storing/fetching starts here
          var resource = undefined;

          if (responseStrategy === "network-first") {
            resource = networkFirstResponse(event, urlString, cacheUrl);
          }
          // 'cache-first' otherwise
          // (responseStrategy has been validated before)
          else {
            resource = cacheFirstResponse(event, urlString, cacheUrl);
          }

          event.respondWith(resource);
        });

        self.addEventListener("message", function(e) {
          if (e.data === "updateDESU!") {
            console.log("[SW] received updateDESU & delete→" + CACHE_NAME);
            caches.delete(CACHE_NAME); // ブラウザ側(main.js)からSWスクリプト更新時イベントで受け取ったメッセージならキャッシュ削除
          }
          var data = e.data;
          if (!data) return;

          switch (data.action) {
            case "skipWaiting":
              {
                if (self.skipWaiting) self.skipWaiting();
              }
              break;
          }
        });

        function cacheFirstResponse(event, urlString, cacheUrl) {
          handleNavigationPreload(event);

          return cachesMatch(cacheUrl, CACHE_NAME).then(function(response) {
            if (response) {
              if (DEBUG) {
                console.log(
                  "[SW] ",
                  "URL [" + cacheUrl + "](" + urlString + ") from cache"
                );
              }

              return response;
            }

            // Load and cache known assets
            var fetching = fetch(event.request).then(function(response) {
              if (!response.ok) {
                if (DEBUG) {
                  console.log(
                    "[SW] ",
                    "URL [" +
                      urlString +
                      "] wrong response: [" +
                      response.status +
                      "] " +
                      response.type
                  );
                }

                return response;
              }

              if (DEBUG) {
                console.log("[SW] ", "URL [" + urlString + "] from network");
              }

              if (cacheUrl === urlString) {
                (function() {
                  var responseClone = response.clone();
                  var storing = caches
                    .open(CACHE_NAME)
                    .then(function(cache) {
                      return cache.put(urlString, responseClone);
                    })
                    .then(function() {
                      console.log("[SW] ", "Cache asset: " + urlString);
                    });

                  event.waitUntil(storing);
                })();
              }

              return response;
            });

            return fetching;
          });
        }

        function networkFirstResponse(event, urlString, cacheUrl) {
          return fetchWithPreload(event)
            .then(function(response) {
              if (response.ok) {
                if (DEBUG) {
                  console.log("[SW] ", "URL [" + urlString + "] from network");
                }

                return response;
              }

              // Throw to reach the code in the catch below
              throw response;
            })
            [
              // This needs to be in a catch() and not just in the then() above
              // cause if your network is down, the fetch() will throw
              "catch"
            ](function(erroredResponse) {
              if (DEBUG) {
                console.log(
                  "[SW] ",
                  "URL [" + urlString + "] from cache if possible"
                );
              }

              return cachesMatch(cacheUrl, CACHE_NAME).then(function(response) {
                if (response) {
                  return response;
                }

                if (erroredResponse instanceof Response) {
                  return erroredResponse;
                }

                // Not a response at this point, some other error
                throw erroredResponse;
                // return Response.error();
              });
            });
        }

        function handleNavigationPreload(event) {
          if (
            navigationPreload &&
            typeof navigationPreload.map === "function" &&
            // Use request.mode === 'navigate' instead of isNavigateRequest
            // because everything what supports navigationPreload supports
            // 'navigate' request.mode
            event.preloadResponse &&
            event.request.mode === "navigate"
          ) {
            var mapped = navigationPreload.map(
              new URL(event.request.url),
              event.request
            );

            if (mapped) {
              storePreloadedResponse(mapped, event);
            }
          }
        }

        // Temporary in-memory store for faster access
        var navigationPreloadStore = new Map();

        function storePreloadedResponse(_url, event) {
          var url = new URL(_url, location);
          var preloadResponsePromise = event.preloadResponse;

          navigationPreloadStore.set(preloadResponsePromise, {
            url: url,
            response: preloadResponsePromise
          });

          var isSamePreload = function isSamePreload() {
            return navigationPreloadStore.has(preloadResponsePromise);
          };

          var storing = preloadResponsePromise.then(function(res) {
            // Return if preload isn't enabled or hasn't happened
            if (!res) return;

            // If navigationPreloadStore already consumed
            // or navigationPreloadStore already contains another preload,
            // then do not store anything and return
            if (!isSamePreload()) {
              return;
            }

            var clone = res.clone();

            // Storing the preload response for later consume (hasn't yet been consumed)
            return caches.open(PRELOAD_CACHE_NAME).then(function(cache) {
              if (!isSamePreload()) return;

              return cache.put(url, clone).then(function() {
                if (!isSamePreload()) {
                  return caches.open(PRELOAD_CACHE_NAME).then(function(cache) {
                    return cache["delete"](url);
                  });
                }
              });
            });
          });

          event.waitUntil(storing);
        }

        function retriveInMemoryPreloadedResponse(url) {
          if (!navigationPreloadStore) {
            return;
          }

          var foundResponse = undefined;
          var foundKey = undefined;

          navigationPreloadStore.forEach(function(store, key) {
            if (store.url.href === url.href) {
              foundResponse = store.response;
              foundKey = key;
            }
          });

          if (foundResponse) {
            navigationPreloadStore["delete"](foundKey);
            return foundResponse;
          }
        }

        function retrivePreloadedResponse(event) {
          var url = new URL(event.request.url);

          if (
            self.registration.navigationPreload &&
            navigationPreload &&
            navigationPreload.test &&
            navigationPreload.test(url, event.request)
          ) {
          } else {
            return;
          }

          var fromMemory = retriveInMemoryPreloadedResponse(url);
          var request = event.request;

          if (fromMemory) {
            event.waitUntil(
              caches.open(PRELOAD_CACHE_NAME).then(function(cache) {
                return cache["delete"](request);
              })
            );

            return fromMemory;
          }

          return cachesMatch(request, PRELOAD_CACHE_NAME).then(function(
            response
          ) {
            if (response) {
              event.waitUntil(
                caches.open(PRELOAD_CACHE_NAME).then(function(cache) {
                  return cache["delete"](request);
                })
              );
            }

            return response || fetch(event.request);
          });
        }

        function mapAssets() {
          Object.keys(assets).forEach(function(key) {
            assets[key] = assets[key].map(function(path) {
              var url = new URL(path, location);

              url.hash = "";

              if (externals.indexOf(path) === -1) {
                url.search = "";
              }

              return url.toString();
            });
          });

          hashesMap = Object.keys(hashesMap).reduce(function(result, hash) {
            var url = new URL(hashesMap[hash], location);
            url.search = "";
            url.hash = "";

            result[hash] = url.toString();
            return result;
          }, {});

          externals = externals.map(function(path) {
            var url = new URL(path, location);
            url.hash = "";

            return url.toString();
          });
        }

        function addAllNormalized(cache, requests, options) {
          var bustValue = options.bust;
          var failAll = options.failAll !== false;
          var deleteFirst = options.deleteFirst === true;
          var requestInit = options.request || {
            credentials: "omit",
            mode: "cors"
          };

          var deleting = Promise.resolve();

          if (deleteFirst) {
            deleting = Promise.all(
              requests.map(function(request) {
                return cache["delete"](request)["catch"](function() {});
              })
            );
          }

          return Promise.all(
            requests.map(function(request) {
              if (bustValue) {
                request = applyCacheBust(request, bustValue);
              }

              return fetch(request, requestInit)
                .then(fixRedirectedResponse)
                .then(
                  function(response) {
                    if (!response.ok) {
                      return { error: true };
                    }

                    return { response: response };
                  },
                  function() {
                    return { error: true };
                  }
                );
            })
          ).then(function(responses) {
            if (
              failAll &&
              responses.some(function(data) {
                return data.error;
              })
            ) {
              return Promise.reject(new Error("Wrong response status"));
            }

            if (!failAll) {
              responses = responses.filter(function(data) {
                return !data.error;
              });
            }

            return deleting.then(function() {
              var addAll = responses.map(function(_ref, i) {
                var response = _ref.response;

                return cache.put(requests[i], response);
              });

              return Promise.all(addAll);
            });
          });
        }

        function matchCacheMap(request) {
          var urlString = request.url;
          var url = new URL(urlString);

          var requestType = undefined;

          if (isNavigateRequest(request)) {
            requestType = "navigate";
          } else if (url.origin === location.origin) {
            requestType = "same-origin";
          } else {
            requestType = "cross-origin";
          }

          for (var i = 0; i < cacheMaps.length; i++) {
            var map = cacheMaps[i];

            if (!map) continue;
            if (
              map.requestTypes &&
              map.requestTypes.indexOf(requestType) === -1
            ) {
              continue;
            }

            var newString = undefined;

            if (typeof map.match === "function") {
              newString = map.match(url, request);
            } else {
              newString = urlString.replace(map.match, map.to);
            }

            if (newString && newString !== urlString) {
              return newString;
            }
          }
        }

        function fetchWithPreload(event) {
          if (!event.preloadResponse || navigationPreload !== true) {
            return fetch(event.request);
          }

          return event.preloadResponse.then(function(response) {
            return response || fetch(event.request);
          });
        }
      }

      function cachesMatch(request, cacheName) {
        return caches
          .match(request, {
            cacheName: cacheName
          })
          .then(function(response) {
            if (isNotRedirectedResponse(response)) {
              return response;
            }

            // Fix already cached redirected responses
            return fixRedirectedResponse(response).then(function(
              fixedResponse
            ) {
              return caches
                .open(cacheName)
                .then(function(cache) {
                  return cache.put(request, fixedResponse);
                })
                .then(function() {
                  return fixedResponse;
                });
            });
          })
          [
            // Return void if error happened (cache not found)
            "catch"
          ](function() {});
      }

      function applyCacheBust(asset, key) {
        var hasQuery = asset.indexOf("?") !== -1;
        return (
          asset +
          (hasQuery ? "&" : "?") +
          "__uncache=" +
          encodeURIComponent(key)
        );
      }

      function isNavigateRequest(request) {
        return (
          request.mode === "navigate" ||
          request.headers.get("Upgrade-Insecure-Requests") ||
          (request.headers.get("Accept") || "").indexOf("text/html") !== -1
        );
      }

      function isNotRedirectedResponse(response) {
        return (
          !response ||
          !response.redirected ||
          !response.ok ||
          response.type === "opaqueredirect"
        );
      }

      // Based on https://github.com/GoogleChrome/sw-precache/pull/241/files#diff-3ee9060dc7a312c6a822cac63a8c630bR85
      function fixRedirectedResponse(response) {
        if (isNotRedirectedResponse(response)) {
          return Promise.resolve(response);
        }

        var body =
          "body" in response ? Promise.resolve(response.body) : response.blob();

        return body.then(function(data) {
          return new Response(data, {
            headers: response.headers,
            status: response.status
          });
        });
      }

      function copyObject(original) {
        return Object.keys(original).reduce(function(result, key) {
          result[key] = original[key];
          return result;
        }, {});
      }

      function logGroup(title, assets) {
        console.groupCollapsed("[SW] ", title);

        assets.forEach(function(asset) {
          console.log("Asset:", asset);
        });

        console.groupEnd();
      }
      WebpackServiceWorker(__wpo, {
        loaders: {},
        cacheMaps: [],
        navigationPreload: false
      });
      module.exports = __webpack_require__(1);

      /***/
    },
    /* 1 */
    /***/ function(module, exports) {
      /***/
    }
    /******/
  ]
);
